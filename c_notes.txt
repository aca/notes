.i files = preprocessor output (e.g. build/src/nvim/auto/ex_docmd.i)

pointer arithmetic:
    `ptr++` advances the pointer by the size of the pointed-to type.
    Incrementing (void *) is illegal. http://stackoverflow.com/a/3524270/152142

*_r function variants (rand_r, localtime_r, ...) are thread-reentrant ("restartable")[1]
    However, they are not "signal handler reentrant"[2]
    [1] http://www.unix.org/whitepapers/reentrant.html
    [2] http://stackoverflow.com/a/18199867/152142

popen() essentially does a combination of (pipe, dup stdin/stdout/stderr, fork, execl)
http://stackoverflow.com/a/24296225/152142

strace 4.9 (with libunwind), -k option shows backtrace of syscalls
        https://github.com/neovim/neovim/issues/1932#issuecomment-72747152
    strace -k -e trace=chdir nvim -u NONE -echdir -c ":q"
    chdir("/home/raf")                      = 0
     > /lib64/libc-2.20.so(chdir+0x7) [0xd8d27]
     > /usr/bin/nvim(uv_chdir+0x9) [0x1ac3e9]
     > /usr/bin/nvim(init_homedir+0x62) [0xa0c82]
     > /usr/bin/nvim(early_init+0xae) [0x15c47e]
     > /usr/bin/nvim(main+0xa9) [0x33129]
     > /lib64/libc-2.20.so(__libc_start_main+0xf5) [0x21b45]
     > /usr/bin/nvim(_start+0x29) [0x354f8]

REFERENCE
================================================================================
C: A Reference Manual, Fifth Edition. http://www.careferencemanual.com

DEBUG
================================================================================
gdb
    CTRL-X_CTRL-A => TUI mode (zomg!!)

rr: gdb replacment with efficient reverse execution http://rr-project.org

LINKING
================================================================================
todo:
  "ELF Hello World Tutorial" http://www.cirosantilli.com/elf-hello-world/

Main functions of linker:
    RESOLVE undefined symbols.
    DEDUPLICATE. A symbol may be defined only once.
    ADDRESS RELOCATION
        Relocation edits the .text section of object files to translate object
        file address into the final address of the executable. This must be done
        by the linker because the compiler only sees one input file at a time.

        Compare:
            objdump -dr foo.o
        to:
            objdump -dr foo.out

http://jvns.ca/blog/2013/12/10/day-40-learning-about-linkers/
https://github.com/0xAX/linux-insides/blob/master/Misc/linkers.md
    nm -A foo.o
    objdump -S -r foo.o

"Delete an inline function, save 794 kB"
https://randomascii.wordpress.com/2017/01/22/delete-an-inline-function-save-794-kb/

  > how symbol resolution works in linkers: Linkers start out with the set of
  > object files that you have specified on the command line – the contents of
  > these object files will be included in the final binary (unless the linker
  > can prove that removing them makes no difference). Then the linker builds up
  > a list of unresolved symbols and starts scanning through the set of
  > libraries that were specified on the command line – the object files in
  > these libraries will be included as-needed. Whenever a needed symbol is
  > found in one of the library object files then that object file is added to
  > the list to be linked – it becomes like one of the command-line object
  > files. The process continues until all symbols are resolved.

  > The symbol search order is unspecified by C++ and due to the One Definition
  > Rule (ODR) the search order should not matter. But, an obvious
  > implementation is to repeatedly scan through the libraries, looking for
  > symbols, until there are no more unresolved. This means that if you have two
  > copies of the same symbol then it is undefined which you will get – it
  > depends where you are when you first find that you need it. Since pulling in
  > a symbol pulls in the rest of its object file this means that linking is
  > fundamentally unpredictable. And, if you have ODR violations (as we did)
  > then the results are not even defined.
